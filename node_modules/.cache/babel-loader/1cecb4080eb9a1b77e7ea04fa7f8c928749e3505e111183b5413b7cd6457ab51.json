{"ast":null,"code":"import { isArray, isPlainObject } from 'is-what';\nfunction mergeRecursively(origin, newComer, extensions) {\n  // work directly on newComer if its not an object\n  if (!isPlainObject(newComer)) {\n    // extend merge rules\n    if (extensions && isArray(extensions)) {\n      extensions.forEach(function (extend) {\n        newComer = extend(origin, newComer);\n      });\n    }\n    return newComer;\n  }\n  // define newObject to merge all values upon\n  var newObject = isPlainObject(origin) ? Object.keys(origin).reduce(function (carry, key) {\n    var targetVal = origin[key];\n    // @ts-ignore\n    if (!Object.keys(newComer).includes(key)) carry[key] = targetVal;\n    return carry;\n  }, {}) : {};\n  return Object.keys(newComer).reduce(function (carry, key) {\n    // re-define the origin and newComer as targetVal and newVal\n    var newVal = newComer[key];\n    var targetVal = isPlainObject(origin) ? origin[key] : undefined;\n    // extend merge rules\n    if (extensions && isArray(extensions)) {\n      extensions.forEach(function (extend) {\n        newVal = extend(targetVal, newVal);\n      });\n    }\n    // early return when targetVal === undefined\n    if (targetVal === undefined) {\n      carry[key] = newVal;\n      return carry;\n    }\n    // When newVal is an object do the merge recursively\n    if (isPlainObject(newVal)) {\n      carry[key] = mergeRecursively(targetVal, newVal, extensions);\n      return carry;\n    }\n    // all the rest\n    carry[key] = newVal;\n    return carry;\n  }, newObject);\n}\n/**\r\n * Merge anything recursively.\r\n * Objects get merged, special objects (classes etc.) are re-assigned \"as is\".\r\n * Basic types overwrite objects or other basic types.\r\n *\r\n * @param {(IConfig | any)} origin\r\n * @param {...any[]} newComers\r\n * @returns the result\r\n */\nfunction index(origin) {\n  var newComers = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    newComers[_i - 1] = arguments[_i];\n  }\n  var extensions = null;\n  var base = origin;\n  if (isPlainObject(origin) && origin.extensions && Object.keys(origin).length === 1) {\n    base = {};\n    extensions = origin.extensions;\n  }\n  return newComers.reduce(function (result, newComer) {\n    return mergeRecursively(result, newComer, extensions);\n  }, base);\n}\nexport default index;","map":{"version":3,"names":["isArray","isPlainObject","mergeRecursively","origin","newComer","extensions","forEach","extend","newObject","Object","keys","reduce","carry","key","targetVal","includes","newVal","undefined","index","newComers","_i","arguments","length","base","result"],"sources":["C:/Users/mario/Documents/GitHub/React-resort-websit/node_modules/merge-anything/dist/index.esm.js"],"sourcesContent":["import { isArray, isPlainObject } from 'is-what';\n\nfunction mergeRecursively(origin, newComer, extensions) {\r\n    // work directly on newComer if its not an object\r\n    if (!isPlainObject(newComer)) {\r\n        // extend merge rules\r\n        if (extensions && isArray(extensions)) {\r\n            extensions.forEach(function (extend) {\r\n                newComer = extend(origin, newComer);\r\n            });\r\n        }\r\n        return newComer;\r\n    }\r\n    // define newObject to merge all values upon\r\n    var newObject = (isPlainObject(origin))\r\n        ? Object.keys(origin)\r\n            .reduce(function (carry, key) {\r\n            var targetVal = origin[key];\r\n            // @ts-ignore\r\n            if (!Object.keys(newComer).includes(key))\r\n                carry[key] = targetVal;\r\n            return carry;\r\n        }, {})\r\n        : {};\r\n    return Object.keys(newComer)\r\n        .reduce(function (carry, key) {\r\n        // re-define the origin and newComer as targetVal and newVal\r\n        var newVal = newComer[key];\r\n        var targetVal = (isPlainObject(origin))\r\n            ? origin[key]\r\n            : undefined;\r\n        // extend merge rules\r\n        if (extensions && isArray(extensions)) {\r\n            extensions.forEach(function (extend) {\r\n                newVal = extend(targetVal, newVal);\r\n            });\r\n        }\r\n        // early return when targetVal === undefined\r\n        if (targetVal === undefined) {\r\n            carry[key] = newVal;\r\n            return carry;\r\n        }\r\n        // When newVal is an object do the merge recursively\r\n        if (isPlainObject(newVal)) {\r\n            carry[key] = mergeRecursively(targetVal, newVal, extensions);\r\n            return carry;\r\n        }\r\n        // all the rest\r\n        carry[key] = newVal;\r\n        return carry;\r\n    }, newObject);\r\n}\r\n/**\r\n * Merge anything recursively.\r\n * Objects get merged, special objects (classes etc.) are re-assigned \"as is\".\r\n * Basic types overwrite objects or other basic types.\r\n *\r\n * @param {(IConfig | any)} origin\r\n * @param {...any[]} newComers\r\n * @returns the result\r\n */\r\nfunction index (origin) {\r\n    var newComers = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        newComers[_i - 1] = arguments[_i];\r\n    }\r\n    var extensions = null;\r\n    var base = origin;\r\n    if (isPlainObject(origin) && origin.extensions && Object.keys(origin).length === 1) {\r\n        base = {};\r\n        extensions = origin.extensions;\r\n    }\r\n    return newComers.reduce(function (result, newComer) {\r\n        return mergeRecursively(result, newComer, extensions);\r\n    }, base);\r\n}\n\nexport default index;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}